<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>Heatmaps</title>
		<style>
			html, body {
				height: 100%;
				margin: 0;
				padding: 0;
			}
			#map {
				height: 100%;
			}
			#floating-panel {
				position: absolute;
				top: 10px;
				left: 25%;
				z-index: 5;
				background-color: #fff;
				padding: 5px;
				border: 1px solid #999;
				text-align: center;
				font-family: 'Roboto','sans-serif';
				line-height: 30px;
				padding-left: 10px;
			}
		</style>
		<script src="lib/jquery-1.11.3.js"></script>
		<script src="lib/alasql.min.js"></script>
		<script src="lib/markerclusterer.js"></script>
		<script src="http://maps.google.com/maps/api/js?&libraries=visualization"></script>
		<!-- <script src="http://google-maps-utility-library-v3.googlecode.com/svn/trunk/markerclustererplus/src/markerclusterer.js"></script> -->
	</head>

	<body onload='loadData()'>
		
		<div id="floating-panel">
			<button onclick="toggleHeatmap()">Toggle Heatmap</button>
			<button onclick="toggleMarkers()">Toggle Markers</button>
			<button onclick="changeGradient()">Change gradient</button>
			<button onclick="changeRadius()">Change radius</button>
			<button onclick="changeOpacity()">Change opacity</button>
		</div>
		
		<div id="map"></div>
		<script>
			var map, heatmap, gradientNumber = 0;
			var markerCluster;
			var mapCoordindates = [];
			var gmarkers = [];
			var markerData = {};
			var infowindow = new google.maps.InfoWindow({
				maxWidth: 330
			});
			
			function loadData() {
				console.log("Loading Latitude/Longitude for heatmap...");
				var latlngCSV = 'http://localhost:8000/data/rawlatlongs.csv';
				alasql('SELECT * FROM CSV("'+latlngCSV+'",{headers:true})', [], function(latlngData) {
					console.log("latlong.csv shows " + latlngData.length + " outage reports.");
					// Headers of the csv:
					var headers = ['Latitude','Longitude'];
					for (var i = 0; i < latlngData.length; i++) {
						if (latlngData[i]['Latitude'] != "NOT FOUND") {
							mapCoordindates.push(new google.maps.LatLng(latlngData[i]['Latitude'], latlngData[i]['Longitude']));
						}
					}
					//initMap();
					initMarkers();
				});
			}
			
			function initMarkers() {
				console.log("Loading the data for the markers and infowindows...");
				var csvUrl = 'http://localhost:8000/data/pscdata.csv';
				alasql('SELECT * FROM CSV("'+csvUrl+'",{headers:true})', [], function(data){
					console.log("pscdata.csv shows " + data.length + " outage reports.");
					headers = ['ID','Address','Latitude','Longitude','Date Time From','Date Time To','Fault Location',
									'Partial','Root Cause','Sub Cause','Ticket No','Weather','Customer Hrs','Duration','No Cust Interrupts'];
					console.log("Creating markers...");
					for (var i = 0; i < data.length; i++) {
						if (data[i]['Latitude'] != "NOT FOUND") {
							var dataAddress = data[i]['Address'];
							// If the address is already in the markerData map, then append on values
							if (dataAddress in markerData) {
								var numEntries = markerData[dataAddress]['Num Entries'];
								for (var j = 0; j < headers.length; j++) {
									var headerName = headers[j];
									if (headerName != 'Address' && headerName != 'Latitude' && headerName != 'Longitude' && headerName != 'ID') {
										var strLength = Number(('' + markerData[dataAddress][headerName] + '').length + headerName.length);
										var numExtra = parseFloat(numEntries)-1;
										var extraLength = Number(numExtra*32);
										var expectedLength = extraLength + 45;
										var padAmount = expectedLength - strLength;
										for (var p = 0; p < padAmount; p++) {
											markerData[dataAddress][headerName] += ",";
										}
									}
								}
								numEntries++;
								markerData[dataAddress]['Num Entries'] = numEntries;
								
								for (var j = 0; j < headers.length; j++) {
									var headerName = headers[j];
									if (headerName != 'Address' && headerName != 'Latitude' && headerName != 'Longitude' && headerName != 'ID') {
										markerData[dataAddress][headerName] += '' + data[i][headerName];
									}
								}
							}
							else {
								markerData[dataAddress] = {};
								for (var j = 0; j < headers.length; j++) {
									var headerName = headers[j];
									markerData[dataAddress][headerName] = data[i][headerName];
								}
								markerData[dataAddress]['Num Entries'] = 1;
							}
						}
					}
					initMap();
				});
			}
			/*
			function initMap() {
				console.log("Inside initMap");
				var mapOptions = {
					backgroundColor: '#000000',
					center: {lat: 40.782361, lng: -73.965784},
					mapTypeId: google.maps.MapTypeId.ROADMAP,
					//mapTypeControlOptions: [google.maps.MapTypeId.ROADMAP, 'M_M&S'],
					//mapTypeControlOptions: [google.maps.MapTypeId.ROADMAP, google.maps.MapTypeId.SATELLITE],
					mapTypeControlOptions: [google.maps.MapTypeId.ROADMAP],
					streetViewControl: false,
					zoom: 13
				};
				map = new google.maps.Map(document.getElementById("map"), mapOptions);
				
				heatmap = new google.maps.visualization.HeatmapLayer({
					data: mapCoordindates,
					maxIntensity: 10,
					map: map
				});
			}
			*/
			
			function initMap() {
				console.log("Creating the map...");
				var myCenter = new google.maps.LatLng({lat: 40.782361, lng: -73.965784});
				var mapOptions = {
					zoom: 13, 
					center: myCenter,
					mapTypeId: google.maps.MapTypeId.ROADMAP
				};
				map = new google.maps.Map(document.getElementById('map'), mapOptions); 

				heatmap = new google.maps.visualization.HeatmapLayer({
					data: mapCoordindates,
					maxIntensity: 10,
					map: map
				});
				
				//marker cluster option
				var mcOptions = {
					gridSize: 25,
					maxZoom: 18,
					ignoreHidden: true,
					minimumClusterSize: 3
				};
				
				// Delaying marker cluster creation until after all the markers have been created
				//markerCluster = new MarkerClusterer(map, [], mcOptions);
				var key;
				var count = 0;
				console.log("Adding the markers to the map...");
				for (key in markerData) {
					if (markerData.hasOwnProperty(key)) {
						gmarkers.push(createMarker(key));
						count++;
					}
				}
				
				markerCluster = new MarkerClusterer(map, gmarkers, mcOptions);
				console.log("Done: Added " + count + " markers.");
			}
			
			function createMarker(index) {
				var latlng = new google.maps.LatLng(parseFloat(markerData[index]['Latitude']),parseFloat(markerData[index]['Longitude']));
				var number;
				if (markerData[index]["Num Entries"] >= 9) {
					number = 9;
				}
				else {
					number = markerData[index]["Num Entries"];
				}
				var marker = new google.maps.Marker({
					position: latlng,
					map: map,
					icon: "http://localhost:8000/markers/" + number + ".png",
					title: markerData[index]['Address']
				});
				
				google.maps.event.addListener(marker, 'click', function() {
					infowindow.close();
					
					var text = "<font face='courier'><b>" + markerData[index]['Address'] + " - (" +  markerData[index]['Num Entries'] + ")</b><pre>";
					for (var headerIter = 4; headerIter < headers.length; headerIter++) {
						var headerName = headers[headerIter];
						text +=  "<b>" + headerName + "</b>: " + ('' + markerData[index][headerName] + '').replace(/,/g, '&nbsp;') + "<br>";
					}
					text += "</font></pre>";
					infowindow.setContent(text);
					infowindow.open(map,marker);
				});
				
				// Delaying marker cluster creation until after all the markers have been created
				//markerCluster.addMarker(marker);
				return marker;
			}
			
			function toggleHeatmap() {
				heatmap.setMap(heatmap.getMap() ? null : map);
			}
			
			function toggleMarkers() {
				for (var i = 0; i < gmarkers.length; i++) {
					if (gmarkers[i].visible) {
						gmarkers[i].setVisible(false);
					}
					else {
						gmarkers[i].setVisible(true);
					}
				}
				if (gmarkers[0].visible == false) {
					infowindow.close();
				}
				markerCluster.repaint();
			}
			
			function changeGradient() {
				var gradient;
				if (gradientNumber == 3) {
					gradientNumber = 0;
					heatmap.set('gradient', null);
				}
				else if (gradientNumber == 0) {
					gradient = [
						'rgba(0, 255, 255, 0)',
						'rgba(0, 255, 255, 1)',
						'rgba(0, 191, 255, 1)',
						'rgba(0, 127, 255, 1)',
						'rgba(0, 63, 255, 1)',
						'rgba(0, 0, 255, 1)',
						'rgba(0, 0, 223, 1)',
						'rgba(0, 0, 191, 1)',
						'rgba(0, 0, 159, 1)',
						'rgba(0, 0, 127, 1)',
						'rgba(63, 0, 91, 1)',
						'rgba(127, 0, 63, 1)',
						'rgba(191, 0, 31, 1)',
						'rgba(255, 0, 0, 1)'
					];
					gradientNumber++;
				}
				else if (gradientNumber == 1) {
					gradient = [
						'rgba(255, 0, 0, 0)',
						'rgba(255, 255, 0, 0.9)',
						'rgba(0, 255, 0, 0.7)',
						'rgba(173, 255, 47, 0.5)',
						'rgba(152, 251, 152, 0)',
						'rgba(152, 251, 152, 0)',
						'rgba(0, 0, 238, 0.5)',
						'rgba(186, 85, 211, 0.7)',
						'rgba(255, 0, 255, 0.9)',
						'rgba(255, 0, 0, 1)'
					];
					gradientNumber++;
				}
				else if (gradientNumber = 2) {
					gradient = [
						'rgba(255, 0, 0, 0)',
						'rgba(0, 242, 255, 0.9)',
						'rgba(113, 235, 194, 0.9)',
						'rgba(145, 250, 107, 0.9)',
						'rgba(0, 186, 25, 0.9)',
						'rgba(245, 255, 56, 0.9)',
						'rgba(255, 196, 0, 0.9)',
						'rgba(255, 149, 0, 0.9)',
						'rgba(255, 0, 0, 1)'
					];
					gradientNumber++;
				}
				if (gradientNumber > 0) {
					heatmap.set('gradient', gradient);
				}
			}
			function changeRadius() {
				var newRadius = heatmap.get('radius');
				if (newRadius == null)
					newRadius = 5;
				newRadius += 5;
				
				if (newRadius > 20) {
					newRadius = 5;
				}
				heatmap.set('radius', newRadius);
			}
			function changeOpacity() {
				var newOpacity = heatmap.get('opacity');
				if (newOpacity == null)
					newOpacity = 1;
				
				newOpacity -= 0.25;
				
				if (newOpacity < 0.3)
					newOpacity = 1;
					
				heatmap.set('opacity', newOpacity);
			}
		</script>
	</body>
</html>