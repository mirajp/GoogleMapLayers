<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>Heatmaps</title>
		<style>
			html, body {
				height: 100%;
				margin: 0;
				padding: 0;
			}
			#map {
				position: absolute;
				border: none;
				height: 80%;
				width: 90%;
				left: 0%;
				top: 0%;
			}
			#networks-panel {
				position: absolute;
				border: none;
				width: 10%;
				height: 100%;
				left: 90%;
				top: 0%;
				background-image: none;
				background-color: rgb(255, 255, 230);
			}
			#floating-panel {
				position: absolute;
				top: 10px;
				left: 20%;
				z-index: 2;
				background-color: #fff;
				padding: 5px;
				border: 1px solid #999;
				text-align: center;
				font-family: monospace;
				line-height: 30px;
				padding-left: 10px;
			}
			#query-panel {
				font-family: monospace;
				position: relative;
				border: none;
				left: 0%;
				top: 80%;
				background-image: none;
			}
			#date-panel {
				font-family: monospace;
				display: inline-block;
				padding: 5px;
				position: relative;
				border: none;
				top: 80%;
				background-image: none;
				background-color: rgb(255, 240, 240);
			}
			#customers-panel {
				font-family: monospace;
				display: inline-block;
				padding: 5px;
				position: relative;
				border: none;
				top: 80%;
				background-image: none;
				background-color: rgb(255, 240, 240);
			}
			.labels {
				color: blue;
				display: block;
				background-color: white;
				font-family: "Roboto", sans-serif;
				font-size: 12px;
				font-weight: bold;
				text-align: center;
				width: auto;     
				border: 1px solid black;
				padding: 2px;
				white-space: nowrap;
			}
		</style>
		
		<script src="http://maps.google.com/maps/api/js?&libraries=visualization"></script>
		<script src="lib/jquery-1.11.3.js"></script>
		<script src="lib/alasql.min.js"></script>
		<script src="lib/markerclusterer.js"></script>
		<script src="lib/markerwithlabel_packed.js"></script>
	</head>

	<body onload='loadData()'>
		<div id="floating-panel">
			<button onclick="toggleHeatmap()">Toggle Heatmap</button>
			<button onclick="toggleMarkers()">Toggle Markers</button>
			<button onclick="changeRadius()">Change radius</button>
			<button onclick="changeOpacity()">Change opacity</button>
		</div>
		
		<div id="map"></div>
		<div id="networks-panel">
			NETWORKS PANEL
		</div>
		
		<div id="query-panel">
			<div id="date-panel">
				<fieldset>
				<legend>Time Interval</legend>
				From: &nbsp
				<input type="date" id="fromDate" name="fromDate" size="10" maxlength="10"/> <br>
				To: &nbsp&nbsp&nbsp
				<input type="date" id="toDate" name="toDate" size="10" maxlength="10"/>
				</fieldset>
			</div>
			
			<div id="customers-panel">
				<fieldset>
				<legend>No. Cust. Interrupts</legend>
				From: &nbsp
				<input type="number" id="minCustInt" name="minCustInt" min="0" max="99999" style="width: 75px;"/> <br>
				To: &nbsp&nbsp&nbsp
				<input type="number" id="maxCustInt" name="maxCustInt" min="0" max="99999" style="width: 75px;"/> <br>
				</fieldset>
			</div>
		</div>
		
		<script>
			var map, heatmap, numNetworks = 0;
			
			var networkPolygons = {};
			var heatmapCoords = [];
			var markerCluster = {};
			var gmarkers = [];
			var markerData = {};
			var infowindow = new google.maps.InfoWindow({
				maxWidth: 330
			});
			
			function loadData() {
				var today = new Date();
				var dd = today.getDate();
				var mm = today.getMonth()+1;
				var yyyy = today.getFullYear();
				if (dd<10) {
					dd='0'+dd
				}
				if (mm<10) {
					mm='0'+mm
				}
				today = yyyy+'-'+mm+'-'+dd;
				
				console.log("Creating the map...");
				var myCenter = new google.maps.LatLng({lat: 40.782361, lng: -73.965784});
				var mapOptions = {
					zoom: 13,
					minZoom: 13,
					maxZoom: 18,
					center: myCenter,
					mapTypeId: google.maps.MapTypeId.ROADMAP
				};
				map = new google.maps.Map(document.getElementById('map'), mapOptions);
				
				drawBoundaries();
				initMarkers();
			}
			
			function drawBoundaries() {
				console.log("Drawing network boundaries...");
				
				var kmlPath = "http://localhost:8000/data/networks.xml";
				var request = new XMLHttpRequest();
				request.open("GET", kmlPath, false);
				request.send();
				var xml = request.responseXML;
				var document = xml.documentElement;
				var placemarks = document.getElementsByTagName("Placemark");
				for(var i = 0; i < placemarks.length; i++) {
					var networkCoordinates = [];
					var placemark = placemarks[i];
					
					var names = placemark.getElementsByTagName("name");
					var networkName = names[0].childNodes[0].nodeValue;
					
					var coords = placemark.getElementsByTagName("coordinates");
					var coordsStrs = (coords[0].childNodes[0].nodeValue).split("\n");
					
					for (var j = 0; j < coordsStrs.length; j++) {				
						var vals = (coordsStrs[j].trim()).split(",");
						if (vals.length == 2)
							networkCoordinates.push(new google.maps.LatLng(parseFloat(vals[1]), parseFloat(vals[0])));
					}
					
					networkPolygons[networkName] = makePolygon(networkCoordinates, networkName);
					
					//marker cluster option
					var mcOptions = {
						gridSize: 250,
						maxZoom: 16,
						ignoreHidden: true,
						minimumClusterSize: 2
					};
					markerCluster[networkName] = new MarkerClusterer(map, [], mcOptions);
					numNetworks++;
				}
			}
			
			function initMarkers() {
				console.log("Loading the data for the markers and infowindows...");
				var csvUrl = 'http://localhost:8000/data/pscdata.csv';
				
				alasql('SELECT * FROM CSV("'+csvUrl+'",{headers:true}) ORDER BY CONVERT(date, [Date Time From], 101) ASC', [], function(data){
				//alasql('SELECT * FROM CSV("'+csvUrl+'",{headers:true}) WHERE CONVERT(date, [Date Time From], 101)>=CONVERT(datetime, "07-07-2015", 1) ORDER BY CONVERT(date, [Date Time From], 101) ASC', [], function(data){
				//alasql('SELECT * FROM CSV("'+csvUrl+'",{headers:true}) WHERE [No Cust Interrupts]>10', [], function(data){
					console.log("pscdata.csv shows " + data.length + " outage reports.");
					headers = ['ID','Address','Latitude','Longitude','Date Time From','Date Time To','Fault Location',
									'Partial','Root Cause','Sub Cause','Ticket No','Weather','Customer Hrs','Duration','No Cust Interrupts'];
					
					var minDate = new Date(data[0]['Date Time From']);
					var dd = minDate.getDate();
					var mm = minDate.getMonth()+1;
					var yyyy = minDate.getFullYear();
					if (dd<10) {
						dd='0'+dd
					}
					if (mm<10) {
						mm='0'+mm
					}
					minDate = yyyy+'-'+mm+'-'+dd;
					document.getElementById("fromDate").setAttribute("min", minDate);
					document.getElementById("toDate").setAttribute("min", minDate);
					document.getElementById("fromDate").setAttribute("value", minDate);
					
					var maxDate = new Date(data[data.length-1]['Date Time From']);
					dd = maxDate.getDate();
					mm = maxDate.getMonth()+1;
					yyyy = maxDate.getFullYear();
					if (dd<10) {
						dd='0'+dd
					}
					if (mm<10) {
						mm='0'+mm
					}
					maxDate = yyyy+'-'+mm+'-'+dd;
					document.getElementById("toDate").setAttribute("max", maxDate);
					document.getElementById("fromDate").setAttribute("max", maxDate);
					document.getElementById("toDate").setAttribute("value", maxDate);
					
					console.log("Creating markers...");
					for (var i = 0; i < data.length; i++) {
						if (data[i]['Latitude'] != "NOT FOUND") {
							var dataAddress = data[i]['Address'];
							heatmapCoords.push(new google.maps.LatLng(data[i]['Latitude'], data[i]['Longitude']));
							
							// If the address is already in the markerData map, then append on values
							if (dataAddress in markerData) {
								var numEntries = markerData[dataAddress]['Num Entries'];
								for (var j = 0; j < headers.length; j++) {
									var headerName = headers[j];
									if (headerName != 'Address' && headerName != 'Latitude' && headerName != 'Longitude' && headerName != 'ID') {
										var strLength = Number(('' + markerData[dataAddress][headerName] + '').length + headerName.length);
										var numExtra = parseFloat(numEntries)-1;
										var extraLength = Number(numExtra*32);
										var expectedLength = extraLength + 45;
										var padAmount = expectedLength - strLength;
										for (var p = 0; p < padAmount; p++) {
											markerData[dataAddress][headerName] += ",";
										}
									}
								}
								numEntries++;
								markerData[dataAddress]['Num Entries'] = numEntries;
								
								for (var j = 0; j < headers.length; j++) {
									var headerName = headers[j];
									if (headerName != 'Address' && headerName != 'Latitude' && headerName != 'Longitude' && headerName != 'ID') {
										markerData[dataAddress][headerName] += '' + data[i][headerName];
									}
								}
							}
							else {
								markerData[dataAddress] = {};
								for (var j = 0; j < headers.length; j++) {
									var headerName = headers[j];
									markerData[dataAddress][headerName] = data[i][headerName];
								}
								markerData[dataAddress]['Num Entries'] = 1;
							}
						}
					}
					initMap();
				});
			}
			
			function initMap() {
				console.log("Creating the heatmap...");
				heatmap = new google.maps.visualization.HeatmapLayer({
					data: heatmapCoords,
					maxIntensity: 10,
					opacity: 1,
					map: map
				});
				
				/*
				//marker cluster option
				var mcOptions = {
					gridSize: 25,
					maxZoom: 18,
					ignoreHidden: true,
					minimumClusterSize: 3
				};
				*/
				
				//markerCluster = new MarkerClusterer(map, [], mcOptions);
				var key;
				var count = 0;
				console.log("Adding the markers to the map...");
				for (key in markerData) {
					if (markerData.hasOwnProperty(key)) {
						var newMarker = createMarker(key);
						if (newMarker != undefined) {
							gmarkers.push(createMarker(key));
							count++;
						}
					}
				}
				
				/*
				for (var key in networkPolygons) {
					if (networkPolygons.hasOwnProperty(key)) {
						markerCluster[key].addMarker(marker);
					}
					else {
						console.log(marker);
					}
				}
				*/
				//markerCluster = new MarkerClusterer(map, gmarkers, mcOptions);
				console.log("Map initialized. " + count + " markers on the map.");
			}
			
			function createMarker(index) {
				var latlng = new google.maps.LatLng(parseFloat(markerData[index]['Latitude']),parseFloat(markerData[index]['Longitude']));
				var number;
				if (markerData[index]["Num Entries"] >= 9) {
					number = 9;
				}
				else {
					number = markerData[index]["Num Entries"];
				}
				var marker = new google.maps.Marker({
					position: latlng,
					map: map,
					icon: "http://localhost:8000/markers/" + number + ".png",
					title: markerData[index]['Address']
				});
				
				google.maps.event.addListener(marker, 'click', function() {
					infowindow.close();
					
					var text = "<font face='courier'><b>" + markerData[index]['Address'] + " - (" +  markerData[index]['Num Entries'] + ")</b><pre>";
					for (var headerIter = 4; headerIter < headers.length; headerIter++) {
						var headerName = headers[headerIter];
						text +=  "<b>" + headerName + "</b>: " + ('' + markerData[index][headerName] + '').replace(/,/g, '&nbsp;') + "<br>";
					}
					text += "</font></pre>";
					infowindow.setContent(text);
					infowindow.open(map,marker);
				});
				
				var found = false;
				// key is the network name (e.g. 1M)
				for (var key in networkPolygons) {
					if (networkPolygons.hasOwnProperty(key)) {
						// If the network shape contains the lat long pair, add the marker to the appropriate array corresponding to that network
						if (google.maps.geometry.poly.containsLocation(latlng, networkPolygons[key])) {
							markerCluster[key].addMarker(marker);
							found = true;
						}
					}
				}
				
				if (found == false) {
					console.log("Err: Marker data for " + markerData[index]['Address'] + " could not be matched to a network! (" + markerData[index]['Latitude'] + ", " + markerData[index]['Latitude'] + ")");
					return undefined;
				}
				// Delaying marker cluster creation until after all the markers have been created
				//markerCluster[networkName].addMarker(marker);
				else {
					return marker;
				}
			}
			
			function toggleHeatmap() {
				heatmap.setMap(heatmap.getMap() ? null : map);
			}
			function toggleMarkers() {
				for (var i = 0; i < gmarkers.length; i++) {
					if (gmarkers[i].visible) {
						gmarkers[i].setVisible(false);
					}
					else {
						gmarkers[i].setVisible(true);
					}
				}
				if (gmarkers[0].visible == false) {
					infowindow.close();
				}
				
				for (var key in markerCluster) {
					if (markerCluster.hasOwnProperty(key)) {
						markerCluster[key].repaint();
					}
				}
				//markerCluster.repaint();
			}
			function changeRadius() {
				var newRadius = heatmap.get('radius');
				if (newRadius == null)
					newRadius = 5;
				newRadius += 5;
				
				if (newRadius > 15) {
					newRadius = 5;
				}
				heatmap.set('radius', newRadius);
			}
			function changeOpacity() {
				var newOpacity = heatmap.get('opacity');
				if (newOpacity == null)
					newOpacity = 1;
				
				newOpacity -= 0.25;
				
				if (newOpacity < 0.3)
					newOpacity = 1;
					
				heatmap.set('opacity', newOpacity);
			}
			
			function makePolygon(polyCoords, polyLabel) {
				var marker = new MarkerWithLabel({
					position: new google.maps.LatLng(0, 0),
					draggable: false,
					raiseOnDrag: false,
					map: map,
					labelContent: polyLabel,
					labelAnchor: new google.maps.Point(15, 23),
					labelClass: "labels", // the CSS class for the label
					labelStyle: {
					  opacity: 1.0
					},
					icon: "http://placehold.it/1x1",
					visible: false
				 });
				
				var smpColors = [
					"#0000ff",
					"#ff0000",
					"#00ff00",
					"#00ffff",
					"#ffff00",
					"#ff00ff",
					"#cc00cc",
					"#cccc00",
					"#00cccc"
				];
				var randColor = smpColors[Math.floor(Math.random()*smpColors.length)];
				var poly = new google.maps.Polygon({
					paths: polyCoords,
					draggable: false,
					clickable: true,
					//strokeColor: "#EEEEFF",
					strokeColor: "#333333",
					strokeOpacity: 0.5,
					strokeWeight: 1,
					//fillColor: "#0000ff",
					fillColor: randColor,
					fillOpacity: 0.15,
					map: map
				});

				google.maps.event.addListener(poly, "mousemove", function(event) {
					marker.setPosition(event.latLng);
					marker.setVisible(true);
				});
				google.maps.event.addListener(poly, "mouseout", function(event) {
					marker.setVisible(false);
				});
				//google.maps.event.clearListeners(poly, 'mouseclick');
				
				return poly;
			}
		</script>
	</body>
</html>