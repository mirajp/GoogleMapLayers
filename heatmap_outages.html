<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>Heatmaps</title>
		<style>
			html, body {
				height: 100%;
				margin: 0;
				padding: 0;
			}
			#map {
				position: absolute;
				border: none;
				height: 80%;
				width: 90%;
				left: 0%;
				top: 0%;
			}
			#networks-panel {
				position: absolute;
				border: none;
				width: 10%;
				height: 100%;
				left: 90%;
				top: 0%;
				font-size: 110%;
				background-image: none;
				background-color: rgb(255, 255, 230);
			}
			#floating-panel {
				position: absolute;
				top: 10px;
				left: 20%;
				z-index: 2;
				background-color: #fff;
				padding: 5px;
				border: 1px solid #999;
				text-align: center;
				font-family: monospace;
				line-height: 30px;
				padding-left: 10px;
			}
			#query-panel {
				font-family: monospace;
				position: absolute;
				border: none;
				left: 0%;
				top: 80%;
				background-image: none;
			}
			#recenter-panel {
				font-family: monospace;
				position: absolute;
				border: none;
				left: 38%;
				top: 80%;
				background-image: none;
			}
			#date-panel {
				font-family: monospace;
				display: inline-block;
				padding: 5px;
				position: relative;
				border: none;
				top: 80%;
				background-image: none;
				background-color: rgb(255, 240, 240);
			}
			#customers-panel {
				font-family: monospace;
				display: inline-block;
				padding: 5px;
				position: relative;
				border: none;
				top: 80%;
				background-image: none;
				background-color: rgb(255, 240, 240);
			}
			.labels {
				color: blue;
				display: block;
				background-color: white;
				font-family: "Roboto", sans-serif;
				font-size: 12px;
				font-weight: bold;
				text-align: center;
				width: auto;     
				border: 1px solid black;
				padding: 2px;
				white-space: nowrap;
			}
		</style>
		
		<script src="http://maps.google.com/maps/api/js?&libraries=visualization,places"></script>
		<!-- <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCJX8q3ThLljfIou6UPxhiIDlaSYw6plbs&libraries=places,visualization&callback=initAutocomplete"></script> -->
		<script src="lib/jquery-1.11.3.js"></script>
		<script src="lib/alasql.min.js"></script>
		<script src="lib/markerclusterer.js"></script>
		<script src="lib/markerwithlabel_packed.js"></script>
		<script src="lib/infobubble-compiled.js"></script>
	</head>

	<body onload='loadData()'>
		<div id="floating-panel">
			<button onclick="toggleHeatmap()">Toggle Heatmap</button>
			<button onclick="toggleMarkers()">Toggle Markers</button>
			<button onclick="changeRadius()">Change radius</button>
			<button onclick="changeOpacity()">Change opacity</button>
		</div>
		
		<div id="map"></div>
		<div id="networks-panel">
			<b>Building Outages Per Network</b>
		</div>
		
		<div id="query-panel">
			<fieldset>
				<legend>Filter Outages</legend>
				
				<div id="date-panel">
					<fieldset>
					<legend>Time Interval</legend>
					From: &nbsp
					<input type="date" id="fromDate" name="fromDate" size="10" maxlength="10"/> <br>
					To: &nbsp&nbsp&nbsp
					<input type="date" id="toDate" name="toDate" size="10" maxlength="10"/>
					</fieldset>
				</div>
				
				<div id="customers-panel">
					<fieldset>
					<legend>No. Cust. Interrupts</legend>
					From: &nbsp
					<input type="number" id="minCustInt" value="0" name="minCustInt" min="0" max="99999" style="width: 75px;"/> <br>
					To: &nbsp&nbsp&nbsp
					<input type="number" id="maxCustInt" value="99999" name="maxCustInt" min="0" max="99999" style="width: 75px;"/> <br>
					</fieldset>
				</div>
				
				<p>
					&nbsp
					<button onclick="filter()">Filter</button>
					<button onclick="reset()">Reset</button>
				</p>
			</fieldset>
			
		</div>
			
		<div id="recenter-panel">
			<fieldset>
				<legend>Set Map Center</legend>
				New Location:
				<div id="locationField">
					<input id="autocomplete" placeholder="Enter your address" onFocus="geolocate()" type="text" style='color:blue; font-size:90%; width:300px'></input>
				</div>
				
				<p>
					&nbsp
					<button onclick="recenter()">Recenter</button>
				</p>
			</fieldset>
		</div>
		
		<script>
			var map, heatmap, numNetworks = 0, maxCustInt = 0, minCustInt = Infinity;
			var recenterLocation;
			var overallMinCustInt, overallMaxCustInt;
			var toDateDefault = "", fromDateDefault = "";
			var networkPolygonCoords = {};
			var networkPolygons, heatmapCoords, markerCluster, gmarkers = [], markerData, bubbleData;
			
			// Marker Cluster options
			var mcOptions = {
				imagePath: 'markers/cluster',
				gridSize: 100,
				maxZoom: 15,
				ignoreHidden: true,
				minimumClusterSize: 2
			};
			var infowindow = new google.maps.InfoWindow({
				maxWidth: 330
			});
			
			function recenter() {
				console.log("Recenter picked.");
				map.setCenter(recenterLocation);
				map.setZoom(18);
			}
			
			function initAutocomplete() {
                // Create the autocomplete object, restricting the search to geographical
                // location types.
                autocomplete = new google.maps.places.Autocomplete(
                        /** @type {!HTMLInputElement} */(document.getElementById('autocomplete')),
                        {types: ['geocode']});

                // When the user selects an address from the dropdown, populate the address
                // fields in the form.
                autocomplete.addListener('place_changed', fillInAddress);
            }
			
			function fillInAddress() {
                // Get the place details from the autocomplete object.
				console.log("FillInAddress");
                var place = autocomplete.getPlace();
				console.log(place.geometry.location);
				recenterLocation = place.geometry.location;
            }
			
			function geolocate() {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(function(position) {
                        var geolocation = {
                            lat: position.coords.latitude,
                            lng: position.coords.longitude
                        };
                        var circle = new google.maps.Circle({
                            center: geolocation,
                            radius: position.coords.accuracy
                        });
                        autocomplete.setBounds(circle.getBounds());
                    });
                }
            }
			
			function reset() {
				document.getElementById("fromDate").value = fromDateDefault;
				document.getElementById("toDate").value = toDateDefault;
				document.getElementById("minCustInt").value = overallMinCustInt;
				document.getElementById("maxCustInt").value = overallMaxCustInt;
			}
			
			function filter() {
				console.log("Filtering data points on the criteria:");
				console.log("From Date: " + document.getElementById("fromDate").value);
				var fromDateVal = (document.getElementById("fromDate").value).split("-"); //yyyy-dd-mm
				console.log("To Date: " + document.getElementById("toDate").value);
				var toDateVal = (document.getElementById("toDate").value).split("-"); //yyyy-dd-mm
				console.log("Min No. Cust Int.: " + document.getElementById("minCustInt").value);
				console.log("Max No. Cust Int.: " + document.getElementById("maxCustInt").value);
				var filterParams = {
					fromDate: fromDateVal[1]+"-"+fromDateVal[2]+"-"+fromDateVal[0], //dd-mm-yyyy
					toDate: toDateVal[1]+"-"+toDateVal[2]+"-"+toDateVal[0], //dd-mm-yyyy
					minCust: document.getElementById("minCustInt").value,
					maxCust: document.getElementById("maxCustInt").value
				};
				initMarkers(filterParams);
			}
			
			function loadData() {
				initAutocomplete();
				var today = new Date();
				var dd = today.getDate();
				var mm = today.getMonth()+1;
				var yyyy = today.getFullYear();
				if (dd<10) {
					dd='0'+dd
				}
				if (mm<10) {
					mm='0'+mm
				}
				today = yyyy+'-'+mm+'-'+dd;
				
				console.log("Creating the map...");
				var myCenter = new google.maps.LatLng({lat: 40.782361, lng: -73.965784});
				var mapOptions = {
					zoom: 13,
					minZoom: 12,
					maxZoom: 19,
					center: myCenter,
					mapTypeId: google.maps.MapTypeId.ROADMAP
				};
				map = new google.maps.Map(document.getElementById('map'), mapOptions);
				
				drawBoundaries();
				initMarkers(undefined);
			}
			
			function drawBoundaries() {
				console.log("Drawing network boundaries...");
				networkPolygons = {};
				markerCluster = {};
				
				var kmlPath = "http://localhost:8000/data/networks.xml";
				var request = new XMLHttpRequest();
				request.open("GET", kmlPath, false);
				request.send();
				var xml = request.responseXML;
				var document = xml.documentElement;
				var placemarks = document.getElementsByTagName("Placemark");
				for(var i = 0; i < placemarks.length; i++) {
					var networkCoordinates = [];
					var placemark = placemarks[i];
					
					var names = placemark.getElementsByTagName("name");
					var networkName = names[0].childNodes[0].nodeValue;
					
					var coords = placemark.getElementsByTagName("coordinates");
					var coordsStrs = (coords[0].childNodes[0].nodeValue).split("\n");
					
					for (var j = 0; j < coordsStrs.length; j++) {				
						var vals = (coordsStrs[j].trim()).split(",");
						if (vals.length == 2)
							networkCoordinates.push(new google.maps.LatLng(parseFloat(vals[1]), parseFloat(vals[0])));
					}
					
					networkPolygons[networkName] = makePolygon(networkCoordinates, networkName);
					networkPolygonCoords[networkName] = networkCoordinates;
					markerCluster[networkName] = new MarkerClusterer(map, [], mcOptions);
					numNetworks++;
				}
			}
			
			function initMarkers(filterParams) {
				heatmapCoords = [];
				markerData = {};
				bubbleData = {};
				//marker cluster option
				
				var csvUrl = 'http://localhost:8000/data/pscdata.csv';
				var sqlSelectStr;
				if (filterParams === undefined) {
					console.log("Initial load for all the data for the markers...");
					sqlSelectStr = 'SELECT * FROM CSV("'+csvUrl+'",{headers:true}) ORDER BY CONVERT(date, [Date Time From], 101) ASC';
				}
				else {
					console.log("Removing the heatmap...");
					heatmap.setMap(null);
					
					console.log("Removing the individual markers...");
					for (var i = 0; i < gmarkers.length; i++) {
						gmarkers[i].setMap(null);
					}
					gmarkers = [];
					
					console.log("Removing the marker clusters...");
					for (var key in markerCluster) {
						if (markerCluster.hasOwnProperty(key)) {
							markerCluster[key].setMap(null);
							markerCluster[key].clearMarkers();
							markerCluster[key] = new MarkerClusterer(map, [], mcOptions);
							markerCluster[key].repaint();
						}	
					}
					
					console.log("Loading the filtered data for the markers...");
					sqlSelectStr = 'SELECT * FROM CSV("'+csvUrl+'",{headers:true}) WHERE (CONVERT(date, [Date Time From], 101) >= CONVERT(datetime, "' + filterParams.fromDate + '" , 1) ';
					sqlSelectStr = sqlSelectStr + 'AND CONVERT(date, [Date Time To], 101) <= CONVERT(datetime, "' + filterParams.toDate + '" , 1) ';
					sqlSelectStr = sqlSelectStr + 'AND [No Cust Interrupts] >= ' + filterParams.minCust + ' AND [No Cust Interrupts] <= ' + filterParams.maxCust + ')';
					sqlSelectStr = sqlSelectStr + 'ORDER BY CONVERT(date, [Date Time From], 101) ASC';
					
					//console.log("Sql String:");
					//console.log(sqlSelectStr);
					//" ORDER BY CONVERT(date, [Date Time From], 101) ASC'
					//alasql('SELECT * FROM CSV("'+csvUrl+'",{headers:true}) WHERE CONVERT(date, [Date Time From], 101)>=CONVERT(datetime, "07-07-2015", 1) ORDER BY CONVERT(date, [Date Time From], 101) ASC', [], function(data){
					//alasql('SELECT * FROM CSV("'+csvUrl+'",{headers:true}) WHERE [No Cust Interrupts]>10', [], function(data){
					
				}
				
				alasql(sqlSelectStr, [], function(data){
					console.log("pscdata.csv shows " + data.length + " outage reports.");
					headers = ['ID','Address','Latitude','Longitude','Date Time From','Date Time To','Fault Location',
									'Partial','Root Cause','Sub Cause','Ticket No','Weather','Customer Hrs','Duration','No Cust Interrupts'];
					
					if (filterParams === undefined) {
						var minDate = new Date(data[0]['Date Time From']);
						var dd = minDate.getDate();
						var mm = minDate.getMonth()+1;
						var yyyy = minDate.getFullYear();
						if (dd<10) {
							dd='0'+dd
						}
						if (mm<10) {
							mm='0'+mm
						}
						minDate = yyyy+'-'+mm+'-'+dd;
						document.getElementById("fromDate").setAttribute("min", minDate);
						document.getElementById("toDate").setAttribute("min", minDate);
						document.getElementById("fromDate").setAttribute("value", minDate);
						fromDateDefault = minDate;
						
						var maxDate = new Date(data[data.length-1]['Date Time From']);
						dd = maxDate.getDate();
						mm = maxDate.getMonth()+1;
						yyyy = maxDate.getFullYear();
						if (dd<10) {
							dd='0'+dd
						}
						if (mm<10) {
							mm='0'+mm
						}
						maxDate = yyyy+'-'+mm+'-'+dd;
						document.getElementById("toDate").setAttribute("max", maxDate);
						document.getElementById("fromDate").setAttribute("max", maxDate);
						document.getElementById("toDate").setAttribute("value", maxDate);
						toDateDefault = maxDate;
					}
					
					console.log("Creating markers...");
					minCustInt = Infinity;
					maxCustInt = 0;
					for (var i = 0; i < data.length; i++) {
						if (data[i]['Latitude'] != "NOT FOUND") {
							var dataAddress = data[i]['Address'];
							heatmapCoords.push(new google.maps.LatLng(data[i]['Latitude'], data[i]['Longitude']));
							var infoBubble;
							
							
							// If the address is already in the markerData map, then append on values
							if (dataAddress in markerData) {
								var numEntries = markerData[dataAddress]['Num Entries'];
								infoBubble = bubbleData[dataAddress];
								/*
								for (var j = 0; j < headers.length; j++) {
									var headerName = headers[j];
									if (headerName != 'Address' && headerName != 'Latitude' && headerName != 'Longitude' && headerName != 'ID') {
										var strLength = Number(('' + markerData[dataAddress][headerName] + '').length + headerName.length);
										var numExtra = parseFloat(numEntries)-1;
										var extraLength = Number(numExtra*32);
										var expectedLength = extraLength + 45;
										var padAmount = expectedLength - strLength;
										for (var p = 0; p < padAmount; p++) {
											markerData[dataAddress][headerName] += ",";
										}
									}
								}
								*/
								numEntries++;
								markerData[dataAddress]['Num Entries'] = numEntries;
								/*
								for (var j = 0; j < headers.length; j++) {
									var headerName = headers[j];
									if (headerName != 'Address' && headerName != 'Latitude' && headerName != 'Longitude' && headerName != 'ID') {
										markerData[dataAddress][headerName] += '' + data[i][headerName];
									}
								}
								*/
							}	
							else {
								markerData[dataAddress] = {};
								infoBubble = new InfoBubble({
									minWidth: 200,
									maxWidth: 250,
									minHeight: 190,
									maxHeight: 190
								});
								bubbleData[dataAddress] = infoBubble;
								markerData[dataAddress]['Num Entries'] = 1;
								
								for (var j = 0; j < headers.length; j++) {
									var headerName = headers[j];
									markerData[dataAddress][headerName] = data[i][headerName];
								}
								

							}
							
							var contentStr = "<h2>" + data[i]['Address'] + "</h2>";
							// Add the infobubble data as html string content
							for (var j = 0; j < headers.length; j++) {
								var headerName = headers[j];
								var headerValue = data[i][headerName];
								if (headerName != 'Address' && headerName != 'Latitude' && headerName != 'Longitude' && headerName != 'ID') {
									contentStr += "<b>" + headerName + "</b>: " + headerValue + "<br>"
								}
							}
							infoBubble.addTab(markerData[dataAddress]['Num Entries'], contentStr);
							
							
							var numCustInt = data[i]['No Cust Interrupts'];
							if (numCustInt < minCustInt)
								minCustInt = numCustInt;
							if (numCustInt > maxCustInt)
								maxCustInt = numCustInt;
						}
					}
					document.getElementById("minCustInt").value = minCustInt;
					document.getElementById("maxCustInt").value = maxCustInt;
					
					if (filterParams == undefined) {
						overallMaxCustInt = maxCustInt;
						overallMinCustInt = minCustInt;
					}
					
					initMap();
				});
			}
			
			function moveToNetwork(networkName) {
				console.log("move to network called by network " + networkName)
				var bounds = new google.maps.LatLngBounds();
				var networkBounds = networkPolygonCoords[networkName];
				
				for (i = 0; i < networkBounds.length; i++) {
					bounds.extend(networkBounds[i]);
				}
				
				map.setCenter(bounds.getCenter());
				map.setZoom(14);
				return false;
			}
			
			function initMap() {
				console.log("Creating the heatmap...");
				heatmap = new google.maps.visualization.HeatmapLayer({
					data: heatmapCoords,
					maxIntensity: 10,
					opacity: 1,
					map: map
				});
				
				var dataIter;
				var count = 0;
				console.log("Adding the markers to the map...");
				for (dataIter in markerData) {
					if (markerData.hasOwnProperty(dataIter)) {
						var newMarker = createMarker(dataIter);
						if (newMarker != undefined) {
							gmarkers.push(newMarker);
							count++;
						}
					}
				}
				
				document.getElementById('networks-panel').innerHTML = '<b>Building Outages Per Network</b><p>';
				for (var key in markerCluster) {
					if (markerCluster.hasOwnProperty(key)) {
						document.getElementById('networks-panel').innerHTML += '<b><a id="' + key + '" href="javascript:void(0);" onclick=\"moveToNetwork(\'' + key + '\'); return false;\">' + key + '</a></b>: ' + markerCluster[key].getTotalMarkers() + '<br>';
					}
				}
				document.getElementById('networks-panel').innerHTML += '</p>';
				console.log("Map initialized. " + count + " markers on the map.");
			}
			
			function createMarker(index) {
				var latlng = new google.maps.LatLng(parseFloat(markerData[index]['Latitude']),parseFloat(markerData[index]['Longitude']));
				var number;
				if (markerData[index]["Num Entries"] >= 9) {
					number = 9;
				}
				else {
					number = markerData[index]["Num Entries"];
				}
				var marker = new google.maps.Marker({
					position: latlng,
					map: map,
					icon: "http://localhost:8000/markers/" + number + ".png",
					title: markerData[index]['Address']
				});
				
				
				var infoBubble = bubbleData[index];
				/*
				// Old event listener to swap out text for the infowindow
				google.maps.event.addListener(marker, 'click', function() {
					infowindow.close();
					console.log("click listener's index = " + index);
					var text = "<b>" + markerData[index]['Address'] + " - (" +  markerData[index]['Num Entries'] + ")</b><pre>";
					for (var headerIter = 4; headerIter < headers.length; headerIter++) {
						var headerName = headers[headerIter];
						text +=  "<b>" + headerName + "</b>: " + ('' + markerData[index][headerName] + '').replace(/,/g, '&nbsp;') + "<br>";
					}
					text += "</pre>";
					infowindow.setContent(text);
					infowindow.open(map,marker);
				});
				*/
				// New event listener that displays the tabbed infobubble
				google.maps.event.addListener(marker, 'click', function() {
					if (!infoBubble.isOpen()) {
						infoBubble.open(map, marker);
					}
				});
				
				var found = false;
				// key is the network name (e.g. 1M)
				for (var key in networkPolygons) {
					if (networkPolygons.hasOwnProperty(key)) {
						// If the network shape contains the lat long pair, add the marker to the appropriate array corresponding to that network
						if (google.maps.geometry.poly.containsLocation(latlng, networkPolygons[key])) {
							markerCluster[key].addMarker(marker);
							found = true;
						}
					}
				}
				
				if (found == false) {
					console.log("Err: Marker data for " + markerData[index]['Address'] + " could not be matched to a network! (" + markerData[index]['Latitude'] + ", " + markerData[index]['Latitude'] + ")");
					return undefined;
				}
				else {
					return marker;
				}
			}
			
			function toggleHeatmap() {
				heatmap.setMap(heatmap.getMap() ? null : map);
			}
			function toggleMarkers() {
				for (var i = 0; i < gmarkers.length; i++) {
					if (gmarkers[i].visible) {
						gmarkers[i].setVisible(false);
					}
					else {
						gmarkers[i].setVisible(true);
					}
				}
				if (gmarkers[0].visible == false) {
					infowindow.close();
				}
				
				for (var key in markerCluster) {
					if (markerCluster.hasOwnProperty(key)) {
						markerCluster[key].repaint();
					}
				}
			}
			function changeRadius() {
				var newRadius = heatmap.get('radius');
				if (newRadius == null)
					newRadius = 5;
				newRadius += 5;
				
				if (newRadius > 15) {
					newRadius = 5;
				}
				heatmap.set('radius', newRadius);
			}
			function changeOpacity() {
				var newOpacity = heatmap.get('opacity');
				if (newOpacity == null)
					newOpacity = 1;
				
				newOpacity -= 0.25;
				
				if (newOpacity < 0.3)
					newOpacity = 1;
					
				heatmap.set('opacity', newOpacity);
			}
			
			function makePolygon(polyCoords, polyLabel) {
				var marker = new MarkerWithLabel({
					position: new google.maps.LatLng(0, 0),
					draggable: false,
					raiseOnDrag: false,
					map: map,
					labelContent: polyLabel,
					labelAnchor: new google.maps.Point(15, 23),
					labelClass: "labels", // the CSS class for the label
					labelStyle: {
					  opacity: 1.0
					},
					icon: "http://placehold.it/1x1",
					visible: false
				 });
				
				var smpColors = [
					"#0000ff",
					"#ff0000",
					"#00ff00",
					"#00ffff",
					"#ffff00",
					"#ff00ff",
					"#cc00cc",
					"#cccc00",
					"#00cccc"
				];
				var randColor = smpColors[Math.floor(Math.random()*smpColors.length)];
				var poly = new google.maps.Polygon({
					paths: polyCoords,
					draggable: false,
					clickable: true,
					strokeColor: "#333333",
					strokeOpacity: 0.5,
					strokeWeight: 1,
					fillColor: randColor,
					fillOpacity: 0.15,
					map: map
				});

				google.maps.event.addListener(poly, "mousemove", function(event) {
					marker.setPosition(event.latLng);
					marker.setVisible(true);
				});
				google.maps.event.addListener(poly, "mouseout", function(event) {
					marker.setVisible(false);
				});
				
				return poly;
			}
		</script>
	</body>
</html>