<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>Heatmaps</title>
		<style>
			html, body {
				height: 100%;
				margin: 0;
				padding: 0;
			}
			#map {
				height: 100%;
			}
			#floating-panel {
				position: absolute;
				top: 10px;
				left: 25%;
				z-index: 5;
				background-color: #fff;
				padding: 5px;
				border: 1px solid #999;
				text-align: center;
				font-family: 'Roboto','sans-serif';
				line-height: 30px;
				padding-left: 10px;
			}
			.labels {
				color: blue;
				display: block;
				background-color: white;
				font-family: "Lucida Grande", "Arial", sans-serif;
				font-size: 12px;
				font-weight: bold;
				text-align: center;
				width: auto;     
				border: 1px solid black;
				padding: 3px;
				white-space: nowrap;
			}
		</style>
		<script src="http://maps.google.com/maps/api/js?&libraries=visualization"></script>
		<script src="lib/jquery-1.11.3.js"></script>
		<script src="lib/alasql.min.js"></script>
		<script src="lib/markerclusterer.js"></script>
		<script src="lib/markerwithlabel_packed.js"></script>
	</head>

	<body onload='loadData()'>
		
		<div id="floating-panel">
			<button onclick="toggleHeatmap()">Toggle Heatmap</button>
			<button onclick="toggleMarkers()">Toggle Markers</button>
			<button onclick="changeRadius()">Change radius</button>
			<button onclick="changeOpacity()">Change opacity</button>
		</div>
		
		<div id="map"></div>
		<script>
			var map, heatmap, numNetworks = 0;
			var networkPolygons = {};
			var heatmapCoords = [];
			var markerCluster = {};
			var gmarkers = [];
			var markerData = {};
			var infowindow = new google.maps.InfoWindow({
				maxWidth: 330
			});
			
			function loadData() {
				console.log("Creating the map...");
				var myCenter = new google.maps.LatLng({lat: 40.782361, lng: -73.965784});
				var mapOptions = {
					zoom: 13,
					minZoom: 13,
					maxZoom: 18,
					center: myCenter,
					mapTypeId: google.maps.MapTypeId.ROADMAP
				};
				map = new google.maps.Map(document.getElementById('map'), mapOptions); 
				
				drawBoundaries();
				
				console.log("Loading Latitude/Longitude for heatmap...");
				var latlngCSV = 'http://localhost:8000/data/rawlatlongs.csv';
				alasql('SELECT * FROM CSV("'+latlngCSV+'",{headers:true})', [], function(latlngData) {
					console.log("latlong.csv shows " + latlngData.length + " outage reports.");
					// Headers of the csv:
					var headers = ['Latitude','Longitude'];
					for (var i = 0; i < latlngData.length; i++) {
						if (latlngData[i]['Latitude'] != "NOT FOUND") {
							heatmapCoords.push(new google.maps.LatLng(latlngData[i]['Latitude'], latlngData[i]['Longitude']));
						}
					}
					initMarkers();
				});
			}
			
			function drawBoundaries() {
				console.log("Drawing network boundaries...");
				
				var kmlPath = "http://localhost:8000/data/networks.xml";
				var request = new XMLHttpRequest();
				request.open("GET", kmlPath, false);
				request.send();
				var xml = request.responseXML;
				var document = xml.documentElement;
				var placemarks = document.getElementsByTagName("Placemark");
				for(var i = 0; i < placemarks.length; i++) {
					var networkCoordinates = [];
					var placemark = placemarks[i];
					
					var names = placemark.getElementsByTagName("name");
					var networkName = names[0].childNodes[0].nodeValue;
					
					var coords = placemark.getElementsByTagName("coordinates");
					var coordsStrs = (coords[0].childNodes[0].nodeValue).split("\n");
					
					for (var j = 0; j < coordsStrs.length; j++) {						
						var vals = (coordsStrs[j].trim()).split(",");
						if (vals.length == 2)
							networkCoordinates.push(new google.maps.LatLng(parseFloat(vals[1]), parseFloat(vals[0])));
					}
					
					networkPolygons[networkName] = makePolygon(networkCoordinates, networkName);
					
					//marker cluster option
					var mcOptions = {
						gridSize: 250,
						maxZoom: 16,
						ignoreHidden: true,
						minimumClusterSize: 2
					};
					markerCluster[networkName] = new MarkerClusterer(map, [], mcOptions);
					numNetworks++;
				}
			}
			
			function initMarkers() {
				console.log("Loading the data for the markers and infowindows...");
				var csvUrl = 'http://localhost:8000/data/pscdata.csv';
				alasql('SELECT * FROM CSV("'+csvUrl+'",{headers:true})', [], function(data){
					console.log("pscdata.csv shows " + data.length + " outage reports.");
					headers = ['ID','Address','Latitude','Longitude','Date Time From','Date Time To','Fault Location',
									'Partial','Root Cause','Sub Cause','Ticket No','Weather','Customer Hrs','Duration','No Cust Interrupts'];
					console.log("Creating markers...");
					for (var i = 0; i < data.length; i++) {
						if (data[i]['Latitude'] != "NOT FOUND") {
							var dataAddress = data[i]['Address'];
							// If the address is already in the markerData map, then append on values
							if (dataAddress in markerData) {
								var numEntries = markerData[dataAddress]['Num Entries'];
								for (var j = 0; j < headers.length; j++) {
									var headerName = headers[j];
									if (headerName != 'Address' && headerName != 'Latitude' && headerName != 'Longitude' && headerName != 'ID') {
										var strLength = Number(('' + markerData[dataAddress][headerName] + '').length + headerName.length);
										var numExtra = parseFloat(numEntries)-1;
										var extraLength = Number(numExtra*32);
										var expectedLength = extraLength + 45;
										var padAmount = expectedLength - strLength;
										for (var p = 0; p < padAmount; p++) {
											markerData[dataAddress][headerName] += ",";
										}
									}
								}
								numEntries++;
								markerData[dataAddress]['Num Entries'] = numEntries;
								
								for (var j = 0; j < headers.length; j++) {
									var headerName = headers[j];
									if (headerName != 'Address' && headerName != 'Latitude' && headerName != 'Longitude' && headerName != 'ID') {
										markerData[dataAddress][headerName] += '' + data[i][headerName];
									}
								}
							}
							else {
								markerData[dataAddress] = {};
								for (var j = 0; j < headers.length; j++) {
									var headerName = headers[j];
									markerData[dataAddress][headerName] = data[i][headerName];
								}
								markerData[dataAddress]['Num Entries'] = 1;
							}
						}
					}
					initMap();
				});
			}
			
			function initMap() {
				console.log("Creating the heatmap...");
				heatmap = new google.maps.visualization.HeatmapLayer({
					data: heatmapCoords,
					maxIntensity: 10,
					opacity: 1,
					map: map
				});
				
				/*
				//marker cluster option
				var mcOptions = {
					gridSize: 25,
					maxZoom: 18,
					ignoreHidden: true,
					minimumClusterSize: 3
				};
				*/
				
				//markerCluster = new MarkerClusterer(map, [], mcOptions);
				var key;
				var count = 0;
				console.log("Adding the markers to the map...");
				for (key in markerData) {
					if (markerData.hasOwnProperty(key)) {
						gmarkers.push(createMarker(key));
						count++;
					}
				}
				
				//markerCluster = new MarkerClusterer(map, gmarkers, mcOptions);
				console.log("Done: Added " + count + " markers.");
			}
			
			function createMarker(index) {
				var latlng = new google.maps.LatLng(parseFloat(markerData[index]['Latitude']),parseFloat(markerData[index]['Longitude']));
				var number;
				if (markerData[index]["Num Entries"] >= 9) {
					number = 9;
				}
				else {
					number = markerData[index]["Num Entries"];
				}
				var marker = new google.maps.Marker({
					position: latlng,
					map: map,
					icon: "http://localhost:8000/markers/" + number + ".png",
					title: markerData[index]['Address']
				});
				
				google.maps.event.addListener(marker, 'click', function() {
					infowindow.close();
					
					var text = "<font face='courier'><b>" + markerData[index]['Address'] + " - (" +  markerData[index]['Num Entries'] + ")</b><pre>";
					for (var headerIter = 4; headerIter < headers.length; headerIter++) {
						var headerName = headers[headerIter];
						text +=  "<b>" + headerName + "</b>: " + ('' + markerData[index][headerName] + '').replace(/,/g, '&nbsp;') + "<br>";
					}
					text += "</font></pre>";
					infowindow.setContent(text);
					infowindow.open(map,marker);
				});
				
				var found = false;
				for (var key in networkPolygons) {
					if (networkPolygons.hasOwnProperty(key)) {
						if (google.maps.geometry.poly.containsLocation(latlng, networkPolygons[key])) {
							// key is the network name (e.g. 1M)
							markerCluster[key].addMarker(marker);
							found = true;
						}
					}
				}
				if (found == false)
					console.log("Err: Marker data for " + markerData[index]['Address'] + " could not be matched to a network!");
				// Delaying marker cluster creation until after all the markers have been created
				//markerCluster[networkName].addMarker(marker);
				return marker;
			}
			
			function toggleHeatmap() {
				heatmap.setMap(heatmap.getMap() ? null : map);
			}
			function toggleMarkers() {
				for (var i = 0; i < gmarkers.length; i++) {
					if (gmarkers[i].visible) {
						gmarkers[i].setVisible(false);
					}
					else {
						gmarkers[i].setVisible(true);
					}
				}
				if (gmarkers[0].visible == false) {
					infowindow.close();
				}
				
				for (var key in markerCluster) {
					if (markerCluster.hasOwnProperty(key)) {
						markerCluster[key].repaint();
					}
				}
				//markerCluster.repaint();
			}
			function changeRadius() {
				var newRadius = heatmap.get('radius');
				if (newRadius == null)
					newRadius = 5;
				newRadius += 5;
				
				if (newRadius > 15) {
					newRadius = 5;
				}
				heatmap.set('radius', newRadius);
			}
			function changeOpacity() {
				var newOpacity = heatmap.get('opacity');
				if (newOpacity == null)
					newOpacity = 1;
				
				newOpacity -= 0.25;
				
				if (newOpacity < 0.3)
					newOpacity = 1;
					
				heatmap.set('opacity', newOpacity);
			}
			
			function makePolygon(polyCoords, polyLabel) {
				var marker = new MarkerWithLabel({
					position: new google.maps.LatLng(0, 0),
					draggable: false,
					raiseOnDrag: false,
					map: map,
					labelContent: polyLabel,
					labelAnchor: new google.maps.Point(30, 20),
					labelClass: "labels", // the CSS class for the label
					labelStyle: {
					  opacity: 1.0
					},
					icon: "http://placehold.it/1x1",
					visible: false
				 });
				
				var smpColors = [
					"#0000ff",
					"#ff0000",
					"#00ff00",
					"#00ffff",
					"#ffff00",
					"#ff00ff",
					"#cccccc",
					"#cc00cc",
					"#cccc00",
					"#00cccc",
					"#eeeeee"
				];
				var randColor = smpColors[Math.floor(Math.random()*smpColors.length)];
				var poly = new google.maps.Polygon({
					paths: polyCoords,
					draggable: false,
					clickable: true,
					//strokeColor: "#EEEEFF",
					strokeColor: "#333333",
					strokeOpacity: 0.5,
					strokeWeight: 1,
					//fillColor: "#0000ff",
					fillColor: randColor,
					fillOpacity: 0.15,
					map: map
				});

				google.maps.event.addListener(poly, "mousemove", function(event) {
					marker.setPosition(event.latLng);
					marker.setVisible(true);
				});
				google.maps.event.addListener(poly, "mouseout", function(event) {
					marker.setVisible(false);
				});
				//google.maps.event.clearListeners(poly, 'mouseclick');
				
				return poly;
			}
		</script>
	</body>
</html>